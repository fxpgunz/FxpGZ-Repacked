//**************************************************************************/
// Copyright (c) 1998-2015 Autodesk, Inc.
// All rights reserved.
// 
// These coded instructions, statements, and computer programs contain
// unpublished proprietary information written by Autodesk, Inc., and are
// protected by Federal copyright law. They may not be disclosed to third
// parties or copied or duplicated in any form, in whole or in part, without
// the prior written consent of Autodesk, Inc.
//**************************************************************************/
// DESCRIPTION: Appwizard generated plugin
// AUTHOR: Kevin Vandecar and Drew Avis
//***************************************************************************/

/*
This howto sample illustrates how to set up a menu and associated ActionTable in a 3ds Max plug-in.
It uses a custom ActionTable for our own plug-in actions, and also accesses a couple of existing
3ds Max Actions.

This sample also illustrates how to register and use multi-resolution icons in a menu.  The
icons are compiled using the Qt RCC compiler (see the pre-build steps), and embedded into the
project.  However, you can also load icons from external .RCC files, or even load individual
.PNG files from disk.  See the comments in the source.
*/

#include "maxMenuDemo.h"

// menus:
#include <imenuman.h>
#include <actiontable.h>
#include <maxIcon.h>

#pragma warning( push )
#pragma warning( disable: 4127 4512 )

#include <QtCore/QtCore>
#include <QtGui/QtGui>

#pragma warning( pop )


#define maxMenuDemo2_CLASS_ID	Class_ID(0x4d2541bd, 0xa975469b)

#define ID_ACTION1 1
#define ID_ACTION2 2
const ActionTableId kMyActions = 0x44370c39; // random generated by gencid.exe
const ActionContextId kMyContext = 0x44370c3A; // same

// Action Table Setup

// This packages up our actions into an ActionDescription for our ActionTable
static ActionDescription spActions[] = {
	ID_ACTION1, // ID
	IDS_ACTION1_DESC, // menu1
	IDS_ACTION1,
	IDS_AT_CATEGORY,

	ID_ACTION2,
	IDS_ACTION2_DESC,
	IDS_ACTION2,
	IDS_AT_CATEGORY
};

class MenuDemoActionTable : public ActionTable
{
public:
	MenuDemoActionTable()//ActionTableId id, ActionContextId contextId, TSTR& name, HACCEL hDefaults, int numIds, ActionDescription* pOps, HINSTANCE hInst)
		: ActionTable(kMyActions, kMyContext, TSTR(GetString(IDS_AT_CATEGORY)))//ActionTable(id, contextId, name, hDefaults, numIds, pOps, hInst)
	{
		// You can comment this out, if you want to load files from disk.
		RegisterDynamicResources(GetColorManager()->GetAppFrameColorTheme());
		BuildActionTable(NULL, sizeof(spActions) / sizeof(spActions[0]), spActions, hInstance);

	};
	~MenuDemoActionTable()
	{
		if (mi1 != NULL) { delete mi1; mi1 = NULL; }
		if (mi2 != NULL) { delete mi2; mi2 = NULL; }
		UnregisterDynamicResources();
	};

	MaxIcon* GetIcon(int cmdId) override;
	BOOL IsChecked(int cmdId) override { return 0; };
	BOOL IsEnabled(int cmdId) override { return 1; };

	// Qt support for loading icon resources
	using Theme = IColorManager::AppFrameColorTheme;
	void RegisterDynamicResources(const Theme& theme = Theme::kDarkTheme);
	void UnregisterDynamicResources();

private:
	MaxIcon* mi1 = nullptr;
	MaxIcon* mi2 = nullptr;
	// The registered path for the compiled icon bundles - see the maxMenuDemo.qrc 
	// files,  and the custom build tool on the file on how these .rcc files
	// are being generated.
	QString m_registeredRCCPath;
};

MaxIcon* MenuDemoActionTable::GetIcon(int cmdId)
{
	switch (cmdId)
	{
	case ID_ACTION1:
		if (!mi1)
			//! [MaxBmpFileIcon Example]
			// mi1 = new MaxBmpFileIcon(_T("MenuDemo/Test1")); // This is PNG file on disk at: <3dsmax.exe>\UI_ln\Icons\Dark[Light]\MenuDemo
			mi1 = new MaxBmpFileIcon(_T(":/MenuDemo/Icons/Test1")); // This is inside RCC file on disk, or embedded at location registered in RegisterDynamicResources method
			//! [MaxBmpFileIcon Example]
		return mi1;
	case ID_ACTION2:
		if (!mi2)
			// mi2 = new MaxBmpFileIcon(_T("MenuDemo/Test2")); // This is PNG file on disk at: <3dsmax.exe>\UI_ln\Icons\Dark[Light]\MenuDemo
			mi2 = new MaxBmpFileIcon(_T(":/MenuDemo/Icons/Test2")); // This is inside RCC file on disk, or embedded at location registered in RegisterDynamicResources method
		return mi2;
	}
	return NULL;
}

/// End of Action Table

class MaxMenuDemo : public UtilityObj, ActionCallback
{
public:

	//Constructor/Destructor
	MaxMenuDemo();
	~MaxMenuDemo() override;

	void DeleteThis() override {};

	void BeginEditParams(Interface *ip, IUtil *iu) override;
	void EndEditParams(Interface *ip, IUtil *iu) override;

	void Init(HWND hWnd);
	void Destroy(HWND hWnd);

	// Singleton access
	static MaxMenuDemo* GetInstance()
	{
		static MaxMenuDemo themaxMenuDemo;
		return &themaxMenuDemo;
	}

	// Members to support our menus
	int FindActionItem(TSTR findName);
	void InstallMenu();
	void RemoveMenu();
	int kContextIdMenuExample;

	BOOL ExecuteAction(int id) override;

private:
	static INT_PTR CALLBACK DlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
	HWND   hPanel;
	IUtil* iu;
	Interface* ip;

};

static bool bMenuShow = false;


class maxMenuDemoClassDesc : public ClassDesc2
{
public:
	int IsPublic() override { return TRUE; }
	void* Create(BOOL /*loading = FALSE*/) override { return MaxMenuDemo::GetInstance(); }
	const TCHAR *	ClassName() override { return m_ClassName; }
	SClass_ID SuperClassID() override { return UTILITY_CLASS_ID; }
	Class_ID ClassID() override { return maxMenuDemo2_CLASS_ID; }
	const TCHAR* Category() override { return m_Category; }

	const TCHAR* InternalName() override { return _T("maxMenuDemo2"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE HInstance() override { return hInstance; }					// returns owning module handle

	int NumActionTables() override { return 1; }
	ActionTable* GetActionTable(int) override
	{
		if (s_actionTable == nullptr)
		{
			s_actionTable = new MenuDemoActionTable();
		}
		return s_actionTable;
	}

private:
	ActionTable*	s_actionTable = nullptr;
	TSTR m_ClassName = GetString(IDS_CLASS_NAME);
	TSTR m_Category = GetString(IDS_CATEGORY);
};


ClassDesc2* GetmaxMenuDemoDesc()
{
	static maxMenuDemoClassDesc maxMenuDemoDesc;
	return &maxMenuDemoDesc;
}

//--- maxMenuDemo2 -------------------------------------------------------
MaxMenuDemo::MaxMenuDemo()
	: hPanel(nullptr)
	, iu(nullptr){}

MaxMenuDemo::~MaxMenuDemo(){}

void MaxMenuDemo::BeginEditParams(Interface* ip, IUtil* iu)
{
	this->iu = iu;
	this->ip = ip;
	hPanel = ip->AddRollupPage(
		hInstance,
		MAKEINTRESOURCE(IDD_DIALOG1),
		DlgProc,
		GetString(IDS_PARAMS),
		0);
}

void MaxMenuDemo::EndEditParams(Interface* ip, IUtil*)
{
	this->iu = nullptr;
	this->ip = nullptr;
	ip->DeleteRollupPage(hPanel);
	hPanel = nullptr;
}

void MaxMenuDemo::Init(HWND /*handle*/) {}

void MaxMenuDemo::Destroy(HWND /*handle*/) {}

INT_PTR CALLBACK MaxMenuDemo::DlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	switch (msg)
	{
	case WM_INITDIALOG:
		MaxMenuDemo::GetInstance()->Init(hWnd);
		break;

	case WM_DESTROY:
		MaxMenuDemo::GetInstance()->Destroy(hWnd);
		break;

	case WM_COMMAND:
		if (LOWORD(wParam) == IDC_BUTTON1) // "Install menu" is clicked
		{
			if (!bMenuShow)
			{
				MaxMenuDemo::GetInstance()->InstallMenu();
			}
			else
			{
				MaxMenuDemo::GetInstance()->RemoveMenu();
			}
			bMenuShow = !bMenuShow;
		}

		break;

	case WM_LBUTTONDOWN:
	case WM_LBUTTONUP:
	case WM_MOUSEMOVE:
		GetCOREInterface()->RollupMouseMessage(hWnd, msg, wParam, lParam);
		break;

	default:
		return 0;
	}
	return 1;
}

// This function searches the Main UI action table for some commands
// that we can use to add to the menu. This is NOT required, and is used
// just for this example. You will probably install your own action table
// and assign its commands to the menu items.
int MaxMenuDemo::FindActionItem(TSTR findName)
{
	ActionTable *pTable = GetCOREInterface()->GetActionManager()->FindTable(kActionMainUI);
	assert(pTable);
	for (int i = 0; i < pTable->Count(); i++)
	{
		ActionItem* pAction = (*pTable)[i];
		TSTR desc;
		pAction->GetDescriptionText(desc);
		if (_tcscmp(findName.data(), desc.data()) == 0)
		{
			int cmdID = pAction->GetId();
			return cmdID;
		}
	}

	return -1; // nothing found
}

// Create and install our own menu
// This method installs a menu with four items: the first two are hooked up to existing 
// Max commands.  The second two are hooked up to our own ActionTable and callbacks.
void MaxMenuDemo::InstallMenu()
{
	IMenuManager* manager = GetCOREInterface()->GetMenuManager();
	IMenu* menu = manager->FindMenu(GetString(IDS_EXAMPLEMENU));

	// Check if your menu is already installed
	// For this example it will never be installed because it is removed in the endeditparams, but 
	// this technique should be used if you are not removing it in order to make sure it doesn't get installed again.
	if (menu == NULL)
	{
		IMenuBarContext* menuContext = (IMenuBarContext*)manager->GetContext(kMainMenuBar);
		IMenu* mainMenu = menuContext->GetMenu();

		// Get and activate the main action table. We will find some existing actions later...
		ActionTable *table = GetCOREInterface()->GetActionManager()->FindTable(kActionMainUI);

		// Make sure context is registered
		manager->RegisterMenuBarContext(kContextIdMenuExample, GetString(IDS_EXAMPLEMENU));

		// now add the menu itself...
		IMenu* menuEx = GetIMenu();
		menuEx->SetTitle(GetString(IDS_EXAMPLEMENU));
		manager->RegisterMenu(menuEx, 0);
		IMenuBarContext* context = (IMenuBarContext*)manager->GetContext(kContextIdMenuExample);
		context->SetMenu(menuEx);

		// setup and add the individual menu items
		int id = FindActionItem(_T("Viewport Configuration"));
		if (id > 0)
		{
			IMenuItem* itemSub1 = GetIMenuItem();
			ActionItem* action = table->GetAction(id);
			itemSub1->SetActionItem(action);
			itemSub1->SetUseCustomTitle(true);
			itemSub1->SetTitle(_T("Menu Example: VP Config"));
			menuEx->AddItem(itemSub1);
		}

		id = FindActionItem(_T("Customize User Interface"));
		if (id > 0)
		{
			IMenuItem* itemSub2 = GetIMenuItem();
			ActionItem* action = table->GetAction(id);
			itemSub2->SetActionItem(action);
			itemSub2->SetUseCustomTitle(true);
			itemSub2->SetTitle(_T("Menu Example: Customize UI"));
			menuEx->AddItem(itemSub2);
		}

		// Now we'll add a couple of our own menu items
		// This is using our local action table.

		// Set up our actions / callbacks
		IActionManager* actionMgr = ip->GetActionManager();
		if (actionMgr)
		{
			actionMgr->ActivateActionTable(this, kMyActions);
		}
		ActionTable* table2 = GetmaxMenuDemoDesc()->GetActionTable(0);
		TSTR s = table2->GetName();
		//MenuDemoActionManager::SetUpActions();
		IMenuItem* itemSub3 = GetIMenuItem();
		ActionItem* action = table2->GetAction(ID_ACTION1);
		itemSub3->SetActionItem(action);
		itemSub3->SetUseCustomTitle(true);
		itemSub3->SetTitle(_T("Menu Example: Print something 1"));
		menuEx->AddItem(itemSub3);

		IMenuItem* itemSub4 = GetIMenuItem();
		action = table2->GetAction(ID_ACTION2);
		itemSub4->SetActionItem(action);
		itemSub4->SetUseCustomTitle(true);
		itemSub4->SetTitle(_T("Menu Example: Print something 2"));
		menuEx->AddItem(itemSub4);

		// Make a new "sub" menu item that will be installed to the menu bar
		IMenuItem* itemMainEx = GetIMenuItem();
		itemMainEx->SetSubMenu(menuEx);

		// Add the menu and update the bar to see it.
		mainMenu->AddItem(itemMainEx, -1);
		manager->UpdateMenuBar();
	}

	return;
}

void MaxMenuDemo::RemoveMenu()
{
	IMenuManager* manager = ip->GetMenuManager();
	IMenu* menu = manager->FindMenu(GetString(IDS_EXAMPLEMENU));

	if (menu)
	{
		while (menu->NumItems() > 0)
		{
			menu->RemoveItem(0);
		}

		// Remove menu from context
		IMenuBarContext* context = (IMenuBarContext*)manager->GetContext(kContextIdMenuExample);
		context->SetMenu(NULL);
		manager->UnRegisterMenu(menu);

		// If you want the changes to be saved to the menu file
		// you can use the following. Because the menu in this example is added/removed 
		// when the context switches to the utility plug-in, this is not needed.
		//const TCHAR* menuFileName = manager->GetMenuFile();
		//manager->SaveMenuFile( menuFileName );

		manager->UpdateMenuBar();
	}
}

BOOL MaxMenuDemo::ExecuteAction(int id)
{
	switch (id)
	{
	case ID_ACTION1:
		ip->PushPrompt(_T("Action 1 executed"));

		return true;
	case ID_ACTION2:
		ip->PushPrompt(_T("Action 2 executed"));
		return true;
	}
	return false;
}

#include "Shlwapi.h"
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// Used to register the RCC file, so you can load Icons from it.
//
//
void MenuDemoActionTable::RegisterDynamicResources(const Theme& theme)
{
	// we may have to unregister the previously registered icons.
	UnregisterDynamicResources();

	// This method will register an external RCC file:
	/*
	TCHAR pluginPath[MAX_PATH] = { 0 };
	GetModuleFileName((HINSTANCE)&__ImageBase, pluginPath, _countof(pluginPath));
	PathRemoveFileSpec(pluginPath);
	m_registeredRCCPath = MSTR(pluginPath) + "maxMenuDemo_" +
		((theme == Theme::kDarkTheme) ? "Dark.rcc" : "Light.rcc");
		*/

		// This method, using the :/ path indicator, registers the embedded RCC in maxMenuIcons.cpp
	m_registeredRCCPath = QString(":\maxMenuDemo_") +
		((theme == Theme::kDarkTheme) ? "Dark.rcc" : "Light.rcc");

	bool bReg = QResource::registerResource(m_registeredRCCPath);
	if (!bReg)
	{
		m_registeredRCCPath.clear();
	}
}


//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
void MenuDemoActionTable::UnregisterDynamicResources()
{
	if (!m_registeredRCCPath.isEmpty())
	{
		QResource::unregisterResource(m_registeredRCCPath);
		m_registeredRCCPath.clear();
	}
}
